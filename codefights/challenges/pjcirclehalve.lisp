(defun iterhalve (initial skip)
  (if (> (length initial) 1001)
      (let ((h (halve initial '())))
        (if (= skip 1)
            (iterhalve h (mod (+ 1 (length initial)) 2))
          (iterhalve (cdr h) (mod (+ 1 (length initial)) 2))))
    initial))

(defun halve (initial left)
  (let ((len (length initial)))
    (if (< len 1)
        (reverse left)
      (halve
       (cddr initial)
       (cons (car initial) left)))))

(defun rng (max)
  (let ((v (make-array max)))
    (dotimes (i max)
      (setf (aref v i) (+ 1 i)))
    v))

(defun ts (max)
  (make-array max :initial-element 0))

(defun nextptr (i s d)
    (declare (optimize (speed 3)))
  (dotimes (j s)
    (if (> (aref d (mod (+ i j 1) s)) 0)
        (progn
          (dotimes (k s)
            (if (> (aref d (mod (+ i j k 2) s)) 0)
                (return-from nextptr (mod (+ i j k 2) s))))))))


(defun findwinner (s d)
  (let ((found 0))
    (dotimes (i s)
      (if (> (aref d i) 0)
          (setf found (aref d i))))
    found))

(defun pjCircle (s w)
    (declare (optimize (speed 3)))
  (let* ((ptr 1)
         (stall (coerce (rng s) 'list))
         (ans (ts s))
         (stlst (iterhalve stall 0))
         (st (make-array (length stlst) :initial-contents stlst)))
    (dotimes (i (- s 1))
      (setf (aref ans i) (aref st ptr))
      (setf (aref st ptr) 0)
      (setf ptr (nextptr ptr s st)))
    (setf (aref ans (- s 1)) (findwinner s st))
    (subseq ans (- s w) s)))
