# showed up late and won

def sameElementsNaive(a, b):
    result = 0

    for i in range(len(a)):
        for j in range(len(b)):
            if a[i] == b[j]:
                result += 1
    return result


def chessKnightMoves(cell):
    def isValid(pos):
        return 0 <= pos <= 7

    def getX(pos):
        return ord(pos) - ord('a')

    def getY(pos):
        return ord(pos) - ord('1')

    current_x = getX(cell[0])
    current_y = getY(cell[1])
    result = 0

    for dx in range(-2, 3):
        for dy in range(-2, 3):
            if abs(dx * dy) == 2:
                if isValid(current_x + dx) and isValid(current_y + dy):
                    result += 1
    return result


def add(a, b):
    return a+b


def getsame(n):
    s = str(n)
    first = s[0]
    ct = 1
    for c in s[1:]:
        if c == first:
            ct += 1
        else:
            break
    return ct, str(ct) + first

def lookAndSaySequenceNextElement(element):
    """
    The look-and-say sequence is defined as follows:

Its first term is equal to 1.
The nth term (for n > 1) is generated by reading the (n-1)th term.
Thus,

the second term is 11, generated by reading the first term as "One 1" (There is one 1 in previous term);
the third term is 21, generated by reading the second term as "Two 1";
the fourth term is 1211, generated by reading the third term as "One 2 One 1";
and so on.

Given some element of the look-and-say sequence, generate the next one.
    """
    ans = ""
    while len(element) > 0:
        move, anspart = getsame(element)
        element = element[move:]
        ans += anspart
    return ans


def isDivisibleBy3(inputString):
    """Replace a single * with a digit and check if it's divisible by 3"""
    ans = []
    for d in range(0, 10):
        repl = inputString.replace('*', str(d))
        if int(repl) % 3 == 0:
            ans.append(repl)
    return ans
