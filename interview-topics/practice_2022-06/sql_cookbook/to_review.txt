-- MUST REVIEW: interesting recipes

-- METADATA (Ch. 5)
-- HINT: typing \gdesc instead of ; at the end of the interactive console shows the type of the result
-- \d  shows tables (no ; needed)
-- \d emp  describes emp (no ; needed)

-- rn: row number

-- 1.3
-- 1.7
-- 1.12
-- 1.13a
-- 1.13b

-- 2.5
-- 2.6
-- 3.2
-- 3.3

-- 3.4
-- 3.5
-- 3.6
-- 3.8
-- 3.9
-- 3.10

-- 4.1
-- 4.16

-- 6.1 CTE
-- 6.4

-- 7.1
-- 7.4, 7.5
-- 7.8
-- 7.9
-- 7.10
-- 7.11
-- 7.12
-- 7.13
-- 7.14

-- select current_date; for "now()"
-- date_trunc('year', current_date) returns a timestamp with time zone (might want to cast it as date)
-- 8.1
-- 8.4
-- 8.5 (how to pick a specific name from a list)
-- 8.7

-- 9.2
-- 9.3
-- 9.10
-- 9.12
-- 9.13

-- 10.1
-- 10.2
-- 10.4 (generate_series solution)
-- 10.5

-- 11.1
-- 11.3
-- 11.5
-- 11.6
-- 11.9
-- 11.10
-- 11.12

-- 12.15
-- 12.17
-- 12.19

-- 13.1
-- 13.3
-- 13.4

-- window function() over (...)
-- framing clause
select hiredate, sal, sum(sal) over (order by hiredate
                                     range between unbounded preceding and current row) from emp;

select hiredate, sal, sum(sal) over (order by hiredate
                                     rows between unbounded preceding and current row) from emp;

select hiredate, sal, sum(sal) over (order by hiredate
		                     rows between current row and unbounded following) from emp;

-- frame exclusion
exclude current row
exclude group
exclude ties

select distinct extract(month from hiredate), count(*) over (partition by extract(month from hiredate)) from emp;

-- over (order by col) is actually over (rows between unbounded preceding and current row)
-- over () takes all rows
-- use primary keys in over (order by x, pk) to avoid adding repeated values


-- regexp where
select empno from emp where empno::text similar to '7[0-9][0-5]{2}';

-- LAG leaves space on top (see past)
select hiredate, lag(hiredate) over (order by hiredate), lag(hiredate, 2) over (order by hiredate) from emp;

-- LEAD leaves space on on bottom (see future)
select hiredate, lead(hiredate) over (order by hiredate), lead(hiredate, 2) over (order by hiredate) from emp;

-- conditional
select ename, hiredate, case when hiredate < '2006-01-01' then 'old' else 'new' end emp_time from emp;

-- conditional on column
select ename, case sal when 5000 then 'a lot' else 'ok' end from emp;

-- use coalesce to replace NULLs with a real value
select coalesce(comm, 0) from emp;

-- adding an 'index' column
select row_number() over (order by empno), ename from emp;


-- selecting from an integer range
select i from
  (select generate_series(1, 10) as i) x
where i between 3 and 6;

-- OR

select i from generate_series(1, 10) g(i)
where i between 3 and 6;

-- pivot: crosstab()

-- join ranges
select i, j from generate_series(1, 10) as t(i)
join (select j from generate_series(5, 19) as t(j)) x
on i = j;

-- create range of dates
select * from generate_series('15-jan-1999'::date, '15-dec-1999'::date, '1 month');
-- PROBLEM: looks like because of daylight savings, a day is not included at the end

-- all days of a month
select * from generate_series('2022-07-01'::date, '2022-07-01'::date + interval '1 month' - interval '1 day', '1 day');

-- all first of months
select * from generate_series(date_trunc('year', current_date), date_trunc('year', current_date) + interval '1 year' - interval '1 day', '1 month');

-- alternative method
select '2020-01-15'::date + gs.id - 1 from generate_series(1, 15) as gs(id);
-- subtract 1 to avoid off-by-one error. This returns 15 rows.

-- to_char(hiredate, 'month')

-- casting
select cast('123' as integer);
select total::text;
select '02-feb-2020'::date;

-- replace string
replace(source, old, new);

-- replace characters in string
-- Latin originally did not have J or U, replace them with I and V
select translate('JULIUS', 'JU', 'IV');

-- substr index is 1-based
substr(str, from, count)
select substr('banana', 2); --> anana

select lpad('2', 3, '0'); --> '002'

-- check if any row is returned in a subquery
select exists(select * from emp where sal = 5000); --> t
select exists(select * from emp where sal > 9000); --> f

-- group hires by year and month (similar to first technical interview)
with cte as (
  select ename, hiredate, extract(year from hiredate) || '-' || extract(month from hiredate) as yrmo
  from emp
)
select ename, yrmo, count(*) over (partition by yrmo),
count(*) over () as total
from cte;
-- PROBLEM: without ename, partition will only sum 11 rows, because there are only 11 unique yrmos. window functions run last.
-- group by yrmo; -- culprit, was grouping by before the window function


select distinct extract(month from hiredate), count(*) over (partition by extract(month from hiredate)) from emp;

-- solution: use DISTINCT
select distinct extract(yr from hiredate) as yr, extract(month from hiredate) as mo, count(*) over (partition by extract(yr from hiredate), extract(month from hiredate))
from emp;

-- cleaner
with formatted_dates as (
  select to_char(hiredate, 'yyyy-mm') as yrmo
  from emp
), totals as (
  select yrmo,
  count(*) over (partition by yrmo) as ct
  from formatted_dates
)
select distinct yrmo, ct from totals
order by yrmo;


-- without window function
-- select table with values as outer table, and counts of data as subquery
with cte as (
select yrmo,
(select count(*) from emp e where to_char(hiredate, 'yyyy-mm') = yrmo) as ct
from year_months
)
select yrmo, ct from cte
where ct > 0
order by yrmo;


-- sum(sales) over (order by date1 rows between 2 preceding and current row) should only be valid when there are 3 available rows (first two rows should be NULL)

select sal, sum(sal) over w, count(sal) over w from emp
window w as (order by sal rows between current row and 2 following);
-- then filter out count < 3

-- choose range of results
select * from emp order by sal limit 3 offset 5;
